import { sanityClient } from './sanity-client';

export interface BlogPost {
  _id?: string; // Add _id as optional since it's added by Sanity
  _type: 'post';
  title: string;
  slug: {
    _type: 'slug';
    current: string;
  };
  content: any[];
  excerpt: string;
  category: 'crypto' | 'investments' | 'real-estate';
  tags: string[];
  publishedAt: string;
  seoTitle?: string;
  seoDescription?: string;
  featuredImage?: {
    _type: 'image';
    asset: {
      _ref: string;
    };
  };
  autoGenerated?: boolean;
  source?: string;
}

export class BlogPostsService {
  // Create a new blog post
  static async createPost(postData: Omit<BlogPost, '_type'>): Promise<BlogPost> {
    try {
      const post: BlogPost = {
        _type: 'post',
        ...postData,
      };

      const result = await sanityClient.create(post);
      return result;
    } catch (error) {
      console.error('Error creating blog post:', error);
      throw error;
    }
  }

  // Create multiple posts in batch
  static async createPosts(postsData: Omit<BlogPost, '_type'>[]): Promise<BlogPost[]> {
    try {
      const transaction = sanityClient.transaction();

      postsData.forEach(postData => {
        const post: BlogPost = {
          _type: 'post',
          ...postData,
        };
        transaction.create(post);
      });

      const result = await transaction.commit();
      return result.results.map((r: any) => r.document);
    } catch (error) {
      console.error('Error creating blog posts:', error);
      throw error;
    }
  }

  // Get recent posts
  static async getRecentPosts(limit: number = 10): Promise<BlogPost[]> {
    try {
      const query = `*[_type == "post"] | order(publishedAt desc)[0...${limit}] {
        _id,
        title,
        slug,
        excerpt,
        category,
        tags,
        publishedAt,
        autoGenerated,
        source
      }`;

      const posts = await sanityClient.fetch(query);
      return posts;
    } catch (error) {
      console.error('Error fetching blog posts:', error);
      throw error;
    }
  }

  // Get posts by category
  static async getPostsByCategory(category: string, limit: number = 10): Promise<BlogPost[]> {
    try {
      const query = `*[_type == "post" && category == "${category}"] | order(publishedAt desc)[0...${limit}] {
        _id,
        title,
        slug,
        excerpt,
        category,
        tags,
        publishedAt,
        autoGenerated,
        source
      }`;

      const posts = await sanityClient.fetch(query);
      return posts;
    } catch (error) {
      console.error('Error fetching posts by category:', error);
      throw error;
    }
  }

  // Get post by slug
  static async getPostBySlug(slug: string): Promise<BlogPost | null> {
    try {
      const query = `*[_type == "post" && slug.current == "${slug}"][0] {
        _id,
        title,
        slug,
        content,
        excerpt,
        category,
        tags,
        publishedAt,
        seoTitle,
        seoDescription,
        autoGenerated,
        source
      }`;

      const post = await sanityClient.fetch(query);
      return post || null;
    } catch (error) {
      console.error('Error fetching post by slug:', error);
      throw error;
    }
  }

  // Check if slug exists (to avoid duplicates)
  static async slugExists(slug: string): Promise<boolean> {
    try {
      const query = `count(*[_type == "post" && slug.current == "${slug}"])`;
      const count = await sanityClient.fetch(query);
      return count > 0;
    } catch (error) {
      console.error('Error checking slug existence:', error);
      return false;
    }
  }
}